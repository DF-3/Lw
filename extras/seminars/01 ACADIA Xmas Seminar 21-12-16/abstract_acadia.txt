


We introduce Lw, a new general purpose, statically typed, strict, impure, functional language supporting cutting-edge features and advanced forms of polymorphism for writing robust, reusable and succinct code. It integrates state-of-the-art advancements in the field of programming languages together with a number of novel bits which makes it ideal for writing big as well as small programs: each heavyweight declarative language construct offers an inferred lightweight counterpart, allowing programmers to design large software architectures that seamlessly coexist with more script-like code.

Among its highlights: type and kind inference, System-F types and first-class polymorphism, open-world overloading with automatic context-dependant resolution, implicit function parameters and controlled dynamic scoping, Generalized Algebraic Datatypes (GADTs), row types for polymorphic variants and records, powerful kind system supporting higher-order polymorphism and kind polymorphism, first-class modules and much more.

Resolution of type constraints is central to many language mechanisms, which, combined with overloading, leads to a form of static dispatching that can either be automatic or assisted by the programmer; dually, row-typed records are subject to dynamic dispatching by nature and enables structural subtyping - a.k.a. sound duck typing. And here lies one of Lw's most notable and novel features: users can turn type constraints into records and viceversa anytime by using a pair of special inject/eject operators, converting a non-first-class entity which basically resembles a dictionary into a first-class record value, and the other way round. This makes two worlds communicate: the world of static resolution and the world of dynamic resolution. Languages out there typically do not define a clear symmetry in this respect; plus, a lot of boilterplate code is often required for switching between the two worlds, if possible at all.
In Lw this symmetry is crucial and explitly designed, encouraging code reuse.
